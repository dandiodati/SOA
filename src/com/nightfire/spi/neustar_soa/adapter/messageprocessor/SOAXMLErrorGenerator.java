/**
 * This message processor will take the ErrorValue as input generated by Rule Processor
 * and process the ErrorValue and give a String as output in the following format
 * ErrorMessage1*TN1*TN2.....TNn;ErrorMessage2*TN1*TN2.....TNn;ErrorMessage3*TN1*TN2.....TNn;
 * Also this processor set the total number of TNs the request contains, total number of
 * failed TN and the list of failed TNs (with ; separator) in the context.
 *
 * @author  Venkata Ramesh Chimata
 * @version 1.0
 * @Copyright (c) 2005-06 NeuStar, Inc. All rights reserved. The source code
 * provided herein is the exclusive property of NeuStar, Inc. and is considered
 * to be confidential and proprietary to NeuStar.
 
 *@see import com.nightfire.common.ProcessingException;
 *@see import com.nightfire.spi.common.driver.MessageProcessorBase;
 *@see import com.nightfire.spi.common.driver.MessageProcessorContext;
 *@see import com.nightfire.spi.common.driver.MessageObject;
 *@see import com.nightfire.spi.neustar_soa.utils.SOAConstants;
 *@see import com.nightfire.framework.db.DBInterface;
 *@see import com.nightfire.framework.db.DatabaseException;
 *@see import com.nightfire.framework.message.MessageException;
 *@see import com.nightfire.framework.message.common.xml.XMLMessageBase;
 *@see import com.nightfire.framework.message.parser.xml.XMLMessageParser;
 *@see import com.nightfire.framework.util.CustomerContext;
 *@see import com.nightfire.framework.util.Debug;
 *@see import com.nightfire.framework.util.FrameworkException;
 *@see import com.nightfire.framework.util.StringUtils;
 *@see import com.nightfire.framework.util.NVPair;
 */
 
/** 
	Revision History
	---------------------
	Rev#		Modified By 	Date			Reason
	-----       -----------     ----------		--------------------------
	1			VRameshChimata	03/11/2006		Created
	2			VRameshChimata	09/11/2006		Review Comments incorporated.
	3			VRameshChimata	13/02/2007		Modified with SOA 4.0.1 
												Requirements.
	4           VRameshChimata	05/03/2007		Comments incorporated.
												
  	
 */

package com.nightfire.spi.neustar_soa.adapter.messageprocessor;

import java.util.ArrayList;
import java.util.Properties;
import java.util.StringTokenizer;
import java.util.Collections;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import com.nightfire.common.ProcessingException;
import com.nightfire.spi.common.driver.MessageProcessorBase;
import com.nightfire.spi.common.driver.MessageProcessorContext;
import com.nightfire.spi.common.driver.MessageObject;
import com.nightfire.spi.neustar_soa.utils.SOAConstants;
import com.nightfire.framework.db.DBInterface;
import com.nightfire.framework.db.DatabaseException;
import com.nightfire.framework.message.MessageException;
import com.nightfire.framework.message.common.xml.XMLMessageBase;
import com.nightfire.framework.message.parser.xml.XMLMessageParser;
import com.nightfire.framework.monitor.ThreadMonitor;
import com.nightfire.framework.util.CustomerContext;
import com.nightfire.framework.util.Debug;
import com.nightfire.framework.util.FrameworkException;
import com.nightfire.framework.util.StringUtils;
import com.nightfire.framework.util.NVPair;


public class SOAXMLErrorGenerator extends MessageProcessorBase {	
	
	/**
	 * The Outputlocation.
	 */  
	private String outputLocationMsg = null;

  	/**
  	 * Get the errorMessage
   	 */
	private String errorMessage = null;
	
	/**
	 * Variable strbuffer is used to append the errormessages/values.
	 */
	
	public StringBuffer strbuffer = new StringBuffer();
	
	/**
	 * Get the error Tn's value from context.
	 */ 
	StringBuffer errorTn = new StringBuffer();
	
	/**
	 * Get the failed Tn's value from context.
	 */ 
	
	ArrayList failedTn = new ArrayList();
	
	/**
	 * Get the success Tn's value from context.
	 */
	
	ArrayList successTn = new ArrayList();	

	/**
	 * Initializes this object via its persistent properties.
	 * @param key  Property-key to use for locating initialization properties.
	 * @param type Property-type to use for locating initialization properties.
	 * @exception ProcessingException when initialization fails
	 */

	public void initialize (String key, String type)
		throws ProcessingException {

		//Call base class method to load the properties.
		super.initialize( key, type );

		//Get configuration properties specific to this processor.
		if ( Debug.isLevelEnabled( Debug.SYSTEM_CONFIG )) {
			Debug.log(
				Debug.SYSTEM_CONFIG,
				"SOAXMLErrorGenerator: Initializing...");
		}
		
		/**
		 * Get the errorBuffer
		 */
		StringBuffer errorBuffer = new StringBuffer( );

		/**
		 * Get the errorString
		 */
		String errorString=null;
	

		//Get error message local from property
		errorMessage = getRequiredPropertyValue( 
					SOAConstants.INPUT_LOC_ERROR_MESSAGE_PROP,errorBuffer );
								
		//Get the ouput local from property
		 outputLocationMsg = getPropertyValue( 
				 SOAConstants.OUTPUT_MSG_LOC , errorString);
		
		
		//If any of the required properties are absent,indicate error to caller
		if ( errorBuffer.length() > 0 ) 
		{
			// Get the errMsg.
			String errMsg = errorBuffer.toString();
			
			Debug.log( Debug.ALL_ERRORS, errMsg );
			
			throw new ProcessingException( errMsg );
		}
    	if( Debug.isLevelEnabled(Debug.SYSTEM_CONFIG) ){
			Debug.log( Debug.SYSTEM_CONFIG, 
								"SOAXMLErrorGenerator: Initialization done." );
		}
	}

	  /**
		* Populate the XML document with new node values.
		* @param  context The context
		* @param  messageObject  Input message to process.
		* @return  The given input, or null.
		* @exception  ProcessingException  Thrown if processing fails.
		* @exception  MessageException  Thrown if message is bad.
		*/

	 public NVPair[] process ( MessageProcessorContext context, 
				MessageObject messageObject )   throws MessageException,
				ProcessingException{
		ThreadMonitor.ThreadInfo tmti =  null;
		try{
	        
			tmti = ThreadMonitor.start( "Message-processor [" + getName() + "] started processing the request" );
			
			if ( messageObject == null ) {
				return null;
			}
			// Create an DOM object out of ErrorMessage
			String inputMsg = getString( errorMessage, context,
					messageObject );
			XMLMessageParser domMsg = new XMLMessageParser(inputMsg);
			Document outMsg = domMsg.getDocument();
			Element firstRoot = outMsg.getDocumentElement();
			
			try{
				
				// Get the successTNList from Customer Context
				successTn =(ArrayList)CustomerContext.getInstance().
													get("successTNList");
                if( Debug.isLevelEnabled(Debug.MSG_STATUS) ){
				  Debug.log(Debug.MSG_STATUS, "successTn :"+ successTn);
				}

				// Get the FailureTNList from Customer Context				
				failedTn =(ArrayList)CustomerContext.getInstance().
													get("failedTNList");

				if( Debug.isLevelEnabled(Debug.MSG_STATUS) ){
				  Debug.log(Debug.MSG_STATUS, "failedTn :"+ failedTn);
				}
				
				}
			catch(FrameworkException fe){

			}
			
			// Intialization value for strErrorMessageTn.
			String strErrorMessageTn = null;

			// Intialization value for strErrorMessage.
			String strErrorMessage = null;

			// Intialization value for strErrorTn.
			String strErrorTn = null;

			// Intialization value for unSortedTn.
			String unSortedTn = null;

			// Intialization value failedTns
			int failedTns = 0;

			// Intialization value successTns
			int successTns = 0;

			// Intialization value for tnFailedList.
			String tnFailedList = null;
	             
			//This contains the elements are containing with data tag.	        
			NodeList nodelist = firstRoot.getElementsByTagName("MESSAGE");
	        
			// Process all the error message generated by Rule Processor
			for(int msgCount = nodelist.getLength()-1; msgCount>=0; msgCount--)
			{
				// Get the MESSAGE node
				Node msgnode = nodelist.item(msgCount);
				
				// Get the value for MESSAGE node
				strErrorMessageTn = XMLMessageBase.getNodeValue(msgnode);

				// Get the actual error message									
				strErrorMessage = strErrorMessageTn.substring(0,
											strErrorMessageTn.indexOf("["));
				// Get all the TN for this error
				strErrorTn = strErrorMessageTn.substring(
										strErrorMessageTn.indexOf("["));
				
				// Variable tokens used to seperate the errorMessage(s) with 
				//TelephoneNumber(s).
				StringTokenizer tokens = new StringTokenizer(strErrorTn,"] [");

				strbuffer.append(strErrorMessage);
				
				ArrayList sortedTns = new ArrayList();
				
				// Add all the TN for the error in the sortedTns list
				while(tokens.hasMoreTokens()){
										
					unSortedTn = (String)tokens.nextToken();

					if( Debug.isLevelEnabled(Debug.MSG_STATUS) ){
					  Debug.log(Debug.MSG_STATUS, "unSortedTn :"+ unSortedTn);
					}
					
					// Adding unsortedTn's to ArrayList.
					if (unSortedTn != null && !unSortedTn.equals(""))
					{
						sortedTns.add(unSortedTn);
					}					
					
				}
				
				// Sort the TN list in ascending order
				Collections.sort(sortedTns);
				
				// Add * as seperator for TNs
				for (int n=0; n < sortedTns.size();n++)
				{
					strbuffer.append('*');
					strbuffer.append(sortedTns.get(n));
				}
				
				strbuffer.append(';');
						
			 }
			if( Debug.isLevelEnabled(Debug.MSG_STATUS) ){ 
			  Debug.log(Debug.MSG_STATUS, "Total Failed TnList:"+ strbuffer.append(""));
			}

			// Get the numebr of failed TN
			if (failedTn != null ) { 
				failedTns = failedTn.size();

				if (failedTn.get(0) == null )
					{
						failedTns = 0;
					}

			}
			
			// Get the number of success TN
			if (successTn != null ) { 
				successTns = successTn.size(); 

				if (successTn.get(0) == null )
				{
					successTns = 0;
				}
			}
			
			
			// Set total number of failed TNs in the context.
			super.set(SOAConstants.FAILED_TN_LOCATION, context,
									messageObject,String.valueOf(failedTns));
	       
			super.set(outputLocationMsg, context,messageObject,
												strbuffer.toString());
			
			// Generate a String containing all the failed TNs (with ; seperator)
			for(int i=0; i<failedTns; i++){
				tnFailedList =(String)failedTn.get(i);
				
				// If it is Range TN
				if (tnFailedList.length() > 12)
				{
					String startTnValue = tnFailedList.substring(8,12);
					String endTnValue = tnFailedList.substring(13);
					
					// Initilization startLine value.
					int startLine = 0;
					
					// Initilization endLine value.
					int endLine = 0;
					
					try{
						startLine = Integer.parseInt(startTnValue);
						endLine = Integer.parseInt(endTnValue);
					}
					catch(NumberFormatException ex){
						Debug.error("Could not parse start TN ["+startTnValue+"]: "+ex);
					}
					// Initilization telephoneNumber value.
					String telephoneNumber = null;
					
					// Construct the errorTN string for the entire Range with ; seperator
					for ( ; startLine <= endLine; startLine++ )
					{
						telephoneNumber = null;
						telephoneNumber = tnFailedList.substring(0,8) 
							+ StringUtils.padNumber( startLine, SOAConstants.TN_LINE,
															 true, '0');
						errorTn.append(telephoneNumber).append(";");
					}
					
				}
				// If Single TN
				else
					{
						errorTn.append(tnFailedList).append(";");
					}
			}
			
			// Set all the failed TN in context (TN with ; separator)
			if(tnFailedList != null){
				super.set(SOAConstants.CONTEXT_TN, context, 
				messageObject, errorTn.toString());
			}
			int totalTns = failedTns + successTns;

			// Set the total number of TNs (the request contains) in context
			super.set(SOAConstants.TOTAL_TN_LOCATION, context, 
									messageObject, String.valueOf(totalTns));
	        
			}
			catch(MessageException me){
				throw me;
			}
			catch(ProcessingException pe){
				throw pe;
			}
			finally
			{
				ThreadMonitor.stop(tmti);
			}
			return( formatNVPair( messageObject ) );
		 }
	    
	//--------------------------For Testing---------------------------------//

	public static void main (String[] args) {

		Properties props = new Properties();
		props.put( "DEBUG_LOG_LEVELS", "ALL" );
		props.put( "LOG_FILE", "D:\\logmap.txt" );
		Debug.showLevels();
		Debug.configureFromProperties(props);
		/*if (args.length != 3) {
			Debug.log(
			Debug.ALL_ERRORS,
			"Synchronus Response:  "
			+ "jdbc:oracle:thin:@192.168.198.42:1521:nsoa rameshc rameshc ");
			return;
		}
		*/		
		args = new String[3];
		args[0]="jdbc:oracle:thin:@192.168.198.42:1521:nsoa";
		args[1] ="rameshc";
		args[2]="rameshc";
		try {

			DBInterface.initialize(args[0], args[1], args[2]);
		} catch (DatabaseException e) {
			Debug.log(
				null,
				Debug.MAPPING_ERROR,
				": " + "Database initialization failure: " + e.getMessage());
		}

		SOAXMLErrorGenerator soaxmlgenerator = new SOAXMLErrorGenerator();

		try {
			soaxmlgenerator.initialize("SOA_ACCOUNT", "SOAXMLErrorGenerator");

			MessageProcessorContext mpx = new MessageProcessorContext();

			MessageObject mob = new MessageObject();

			/** Setting Key,Values  for the Message Object  **/

			
			mob.set("errorMessage",
					"<?xml version=\"1.0\"?>" +
					" "+
					" "+
				"<ErrorMessage>" +
				" "+
				" "+
				"<RuleErrors>" +
				" "+
				" "+
				"<Errors>" +
				" "+
				
					"<ruleerrorcontainer>"+
						"<ruleerror>"+
							"<RULE_ID value=\"TN_2\" />"+
							"<MESSAGE value=\"The valid format for Tn is " +
							"NNN-NNN-NNNN (where N is a numeric character)." +
							"[540-001-2699 ][540-001-5698 ]\" />"+
							"<CONTEXT value=\"/SOAMessage/UpstreamToSOA/" +
							"UpstreamToSOABody/" +
							"SvCreateRequest/Subscription/Tn\" />"+
							"<CONTEXT_VALUE value=\"22222\" />"+
							
						"</ruleerror>"+" "+
								"<ruleerror>"+
									"<RULE_ID value=\"TN_1\" />"+
									"<MESSAGE value=\"AlternativeSPID is " +
									"prohibited on a Port-To-Original " +
									"request.[530-001-9869 ]" +
									"[530-001-9868 ]\"  />"+
									"<CONTEXT value=\"/SOAMessage/" +
									"UpstreamToSOA/UpstreamToSOABody/" +
									"SvCreateRequest/Subscription/Tn\" />"+
									"<CONTEXT_VALUE value=\"22222\" />"+
									
								"</ruleerror>"+" "+
						"<ruleerror>"+
									"<RULE_ID value=\"TN_5\" />"+
									"<MESSAGE value=\"SvType is prohibited" +
									" on a Port-To-Original request." +
									"[530-001-9867 ][530-001-9868 ]\"  />"+
									"<CONTEXT value=\"/SOAMessage/" +
									"UpstreamToSOA" +
									"/UpstreamToSOABody/SvCreateRequest" +
									"/Subscription/Tn\" />"+
									"<CONTEXT_VALUE value=\"22222\" />"+
										
						"</ruleerror>"+" "+
					"</ruleerrorcontainer>" +
					"</Errors>"+
					"</RuleErrors>" +
					"</ErrorMessage>") ;
			
			soaxmlgenerator.process( mpx, mob );

			Debug.log( Debug.BENCHMARK, "Context--->" + mpx.describe() );

		} catch ( ProcessingException pex ) {
			Debug.log( Debug.BENCHMARK,pex.getMessage() );
		} catch ( MessageException mex ) {
			Debug.log( Debug.BENCHMARK,mex.getMessage() );
		}
	} //end of main method
}
